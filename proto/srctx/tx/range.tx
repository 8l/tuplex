module tx


public interface Enumerable< E derives Enumerable<E> > derives Comparable< E > {
    /** returns the last (highest) ordinal for this type */
    public static abstract last_ordinal() -> UInt;

    /** returns the value for the specified ordinal (panics upon out-of-bounds) */
    public static abstract value( ordinal: UInt ) -> E;

    /** returns the ordinal for this value */
    public abstract ordinal() -> UInt;


    public static first() -> E {
        return E.value( 0 );
    }

    public static last() -> E {
        return E.value( E.last_ordinal() );
    }
}



public interface Range< E > derives Sequenceable< E > {
    public abstract sequencer() -> Ref< ~Sequencer<E> >;
    public abstract last_index() -> UInt;
    public abstract at(index : UInt) -> E;
}



/** A range between two values of an Enumerable type. */
public type ERange< E derives Enumerable<E> > derives Tuple, Range< E > {
    _last : UInt;

    public start : E;
    public end   : E;
    public step  : Long;

    public self( start : E, end : E, step : Long ) {
        self.start = start;
        self.end = end;
        self.step = step;

        ## FIXME: review
        if self.step >= 0
            self._last = UInt( ( Long( self.end.ordinal() )   - self.start.ordinal() + 1L ) / self.step );
        else
            self._last = UInt( ( Long( self.start.ordinal() ) - self.end.ordinal()   + 1L ) / -self.step );
    }

    public sequencer() -> Ref< ~ERangeIterator<E> > {
        return new ~ERangeIterator<E>( self );
    }
    public last_index() -> UInt {
        return self._last;
    }
    public at( index : UInt ) -> E {
        assert index <= self._last;
        return E.value( self.start.ordinal() + UInt( index * self.step ) );
    }
}

/** The ERange iterator. */
public type ERangeIterator< E derives Enumerable<E> > derives Tuple, Sequencer< E > {
    range   : &ERange<E>;
    nextVal : ~UInt;

    public self( range : &ERange ) {
        self.range = range;
        self.nextVal = range.start;
    }

    public sequencer() -> Ref< ~ERangeIterator > {
        return self;
    }

    public hasNext() -> Bool {
        return self.nextVal <= self.range.end;
    }

    public next()->ULong  {
        assert self.nextVal <= self.range.end;
        r := self.nextVal;
        self.nextVal = self.nextVal + self.range.step;
        return r;
    }

/*
    public hasPrev() -> Bool {
        return self^.nextVal-self^.range^.step >= self^.range^.first;
    }
 
    public prev()->ULong  {
        if self^.range^.first + self^.range^.step > self^.nextVal
            return self^.range^.first;  ## TODO: panic
        self^.nextVal = self^.nextVal - self^.range^.step;
        return self^.nextVal;
    }
*/
}
