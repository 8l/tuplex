module tx


public interface Enumerable< E derives Enumerable<E> > derives Comparable< E > {
    /** returns the last (highest) ordinal for this type */
    public static abstract last_ordinal() -> UInt;

    /** returns the value for the specified ordinal (panics upon out-of-bounds) */
    public static abstract value( ordinal: UInt ) -> E;

    /** returns the ordinal for this value */
    public abstract ordinal() -> UInt;


    public static first() -> E {
        return E.value( 0 );
    }

    public static last() -> E {
        return E.value( E.last_ordinal() );
    }
}



public interface Range< E > derives Sequenceable< E > {
    public abstract override sequencer() -> Ref< ~Sequencer<E> >;
    public abstract last_index() -> UInt;
    public abstract at(index : UInt) -> E;
}



/** A range between two values of an Enumerable type. */
public type ERange< E derives Enumerable<E> > derives Tuple, Range< E > {
    /** The ERange iterator. */
    public type ERangeIterator derives Tuple, Sequencer< E > {
        range   : &ERange<E>;
        nextIndex : ~UInt;

        public self( range : &ERange<E> ) {
            self.range = range;
            self.nextIndex = 0;
        }

        public override sequencer() -> Ref< ~ERangeIterator > {
            return self;
        }
    
        public override hasNext() -> Bool {
            return self.nextIndex <= self.range.last_index();
        }
    
        public override next() -> E {
            n := self.nextIndex;
            self.nextIndex = self.nextIndex + 1;
            return self.range.at( n );
        }
    
    /*
        public hasPrev() -> Bool {
            return self^.nextVal-self^.range^.step >= self^.range^.first;
        }
     
        public prev()->ULong  {
            if self^.range^.first + self^.range^.step > self^.nextVal
                return self^.range^.first;  ## TODO: panic
            self^.nextVal = self^.nextVal - self^.range^.step;
            return self^.nextVal;
        }
    */
    }

    _last : UInt;

    public start : E;
    public end   : E;
    public step  : Long;

    public self( start : E, end : E, step : Long ) {
        self.start = start;
        self.end = end;
        self.step = step;

        ## FIXME: review
        if self.step >= 0
            self._last = UInt( ( Long( self.end.ordinal() )   - self.start.ordinal() + 1L ) / self.step );
        else
            self._last = UInt( ( Long( self.start.ordinal() ) - self.end.ordinal()   + 1L ) / -self.step );
    }

    public override sequencer() -> Ref< ~ERangeIterator > {
        return new ~ERangeIterator( self );
    }
    public override last_index() -> UInt {
        return self._last;
    }
    public override at( index : UInt ) -> E {
        assert index <= self._last;
        return E.value( self.start.ordinal() + UInt( index * self.step ) );
    }
}
