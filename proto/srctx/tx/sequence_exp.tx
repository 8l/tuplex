## module tx


/** A type whose values are "enumerable": enumerable, finite, known.
 * (E.g. integers, enums.)
 * Ordinals always start from 0.
 * Doesn't provide an iterator - a Range<E derives Enumerable> does that.
 */
public interface EnumerableI derives Interface {
    /** returns the number of values */
    public static abstract cardinality() ULong

##    /** returns the value for the specified ordinal (panics upon out-of-bounds) */
##    public static abstract value( ordinal: ULong ) Self

    /** returns the ordinal for this value */
    public abstract ordinal() ULong

/* these are derivable from the above
e = Enum.first()
e = Enum.last()
e = e.successor()
e = e.successor( step : UInt )
*/
}



/** An ERange is a virtual, indicable sequence of an enumerable type. */
public type ERange<E derives Enumerable> derives IndicableI<E> {
  ## NOTE: This type requires dynamic type parameter support.
    public first : E
    public last  : E
    public step  : Long

    public self( f : E, l : E, s : Long ) { first = f; last = l; step = s }

    public sequencer() ~IteratorI<E>   { return ERangeIterator(first, last, step) }
    public count() ULong              { return (last - first + 1) / step }
    public at(index : ULong) Opt<E>   { r := first + index * step; return ( r<=last ? r : NULL ) }
}



/** The typical 'floating point' range type. Conceptually implements IndicableI. */
public type DRange  /*derives ERange<Double>*/ {
    public first : Double
    public last  : Double
    public step  : Double

    public self( f : Double, l : Double, s : Double ) { self.first = f; self.last = l; self.step = s }

    public sequencer() ~DRangeIterator  { return DRangeIterator(self) }
    public count() ULong                { return ULong( (self.last - self.first) / self.step ) + 1 }  ## returns ULONG_MAX upon overflow
    public at(index : ULong) Double     { r := self.first + index * self.step; return ( r <= self.last ? r : self.last ) }
}
