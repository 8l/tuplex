
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors)

Fix / revise TYPE parameter declaration. See inheritance doc in TxTypeSpecialization. From genericstest2.tx:
    ----P--I--- my.RInt.tx#Ref#T                                 TYPE      = tx.Int
    ----------- my.ATypeRInt                                     TYPE      = my.AType$tx#Ref  ## is =, should not contain members right?
    ----P--I--- my.ATypeRInt.my#AType#S                          TYPE      = my.RInt          ## should be "moved" to my.AType$tx#Ref ?
    
    ----P--I--- my.AType$tx#Ref                                  TYPE      : tx.Tuple
    ----P--I--- my.AType$tx#Ref.S                                TYPE      = my.ATypeRInt.my#AType#S  ## this seems circular...
    ----P--I--- my.AType$tx#Ref.$GenericBase                     TYPE      = my.AType<TYPE S>

Fix instantiation of ref-constrained type parameters - they should get unique names,
  which means that ref targets must be partly resolved (producing e.g. my.AType$tx#Ref$Int above)

Refactor TxType instantiation - multi-pass so that "cyclic" references possible 

Type conversions (with if statements)

Dataspace syntax support, continued

Range typeclass

for-loops

Tuple literals
Array literals

Destructors

Union typeclass

Full dataspaces support

Shared objects

Generic type instance fields support (with Any contraint type)
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Make TxType be fully defined upon construction (during type resolution pass)
 - Means base types are fully resolved by subtype construction
 - Static (vtable) and instance field layouts can be done upon construction
 - Target (LLVM) type construction could also be done right away

Enum typeclass
