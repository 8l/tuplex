
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors) - DONE

Author test harness / automatic testing suite - DONE

Change statement syntax from \n to ; - DONE

Change function header syntax from 'func' to ()-> - DONE

Implement syntactic sugar for automatic reference dereferencing (implicit '^') - DONE

Refactor TxType instantiation - multi-pass so that "cyclic" references possible - DONE

Fix instantiation of ref-constrained type parameters (they should get unique names like other specializations) - DONE

Fix / revise TYPE parameter declaration ("hashed" binding members) - DONE

Refactor expression conversion wrapping so that each specialization-index has an independent conversion evaluation - DONE

Make fields be "bindings to entities" rather than "entities" - SORT-OF-DONE
 - in order to fix multi-instantiation in e.g:
  stackObj := AType();  ## allocates twice & copies! 

==>> Implicit default constructor initializer for stack fields without explicit initializers:
  Value* TxFieldStmtNode::code_gen(LlvmGenerationContext& context, GenScope* scope) const
        // TODO: invoke default constructor


Proper support for VALUE bindings, and implement correct Array type handling

String datatype

Range typeclass

for-loops

Proper mutability handling:
 - in compound expressions, e.g. mut.immut.mut.immut ...
 - mutating and non-mutating methods
 - review inheritance and mutability (including interface adapters)

Implement implicit instance initializer function for types' instance members' inlined initializers

Implement implicit static initializer function for types' static members and static code?

Type reflection, at least for autotesting, some ideas:
    assert static_type(var) == static_type(Ref<Parent>)
    assert type(var^) == type(Child)
    #exptype( var, Ref<Parent> )  ## compilation test, no code generated
    #exptype( var, "$local.Foo.$type" )  ## compilation test, no code generated

Type conversions (with if statements)

Dataspace syntax support, continued

break and continue out of nested loops

Tuple literals
Array literals

Destructors

Union typeclass

Full dataspaces support

Shared objects

Implicit constructors: if no constructor specified, automatically generate constructors:
 - default (zero arguments) constructor if base type and all members without inlined initializers allow default construction
 - "full" constructor if base type allows default construction and one argument for each member (?)
 
Constructor initialization validation check: That each constructor properly initializes all members (without inlined initializers)

Generic type instance fields support (with Any contraint type)
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Enum typeclass
