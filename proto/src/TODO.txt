
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

=======================
Generic type instance fields support
 To support declaring instance fields of parameterized type by reference
 Requires creating 'concrete' member entity copies in specialized subtype

 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
   SymbolScope created in declaration phase
   Entities (perhaps renamed as Definitions) created in resolution phase
   Entities to handle member lookup (including providing "specialized members" of specialized generic types)

=======================

Interfaces

Type conversions (with if statements)

Dataspace syntax support, continued

Range typeclass

for-loops

Tuple literals
Array literals

Destructors

Union typeclass

Full dataspaces support

Shared objects

Make TxType be fully defined upon construction (during type resolution pass)
 - Means base types are fully resolved by subtype construction
 - Static (vtable) and instance field layouts can be done upon construction
 - Target (LLVM) type construction could also be done right away

Dynamic generics support
 - To support declaring instance fields of dynamically resolved type by value (not just reference)
 - Requires making the AST for a generic type definition re-entrant, and reprocessed for each specialization

Enum typeclass
