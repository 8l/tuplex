
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors) - DONE

Author test harness / automatic testing suite - DONE

Change statement syntax from \n to ; - DONE

Change function header syntax from 'func' to ()-> - DONE

Implement syntactic sugar for automatic reference dereferencing (implicit '^') - DONE

Refactor TxType instantiation - multi-pass so that "cyclic" references possible - DONE

Fix instantiation of ref-constrained type parameters (they should get unique names like other specializations) - DONE

Fix / revise TYPE parameter declaration ("hashed" binding members) - DONE

Refactor expression conversion wrapping so that each specialization-index has an independent conversion evaluation - DONE

Generic type instance fields support (with Any contraint type) - DONE
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Proper recursive expression checking (fields; types) - DONE

Remove validation pass (move checks to resolution pass) - DONE

Support recursive type definition by reference (CRTP) (e.g. type Bar Foo< Ref<Bar> >) - DONE!!!!!

Implement "development mode" in compiler, if disabled then:
 - bc file generated by default - DONE
 - no jit by default - DONE
 - no compiler assertions - DONE
 - no trace logging invocations - MOSTLY DONE (Symbol logging remains)

Make fields be "bindings to entities" rather than "entities" - SORT-OF-DONE
 - in order to fix multi-instantiation in e.g:
  stackObj := AType();  ## allocates twice & copies! 

Review conversion node handling
 - should be allocated in node constructors (not decl/resolve passes)
 - check/fix AST copy in BinOp, UnaryOp

Type reflection, at least for autotesting, some ideas:
    assert static_type(var) == static_type(Ref<Parent>)
    assert type(var^) == type(Child)
    #exptype( var, Ref<Parent> )  ## compilation test, no code generated
    #exptype( var, "$local.Foo.$type" )  ## compilation test, no code generated


Make VALUE type parameters proper instance fields and ensure they're correctly initialized
Proper support for VALUE bindings, and implement correct Array type handling

Simple for-loops

Sequence interfaces

String datatype

Implement debugging info


Autotests for conversions and default constructions for elementary types
  - both expression construction, stack field construction, and static construction

Generate function header declarations before lexical-order code generation
 - should avoid auto-forward-declaring functions

Generate statically constant operations for statically constant value expressions
 - should also enable arbitrary declaration order of global constants 

Dynamic-length arrays tests - bounds checking, copying, etc

Syntactic sugar for ref and array types in type arguments (possibly chained), e.g. Subtype<&Int> instead of Subtype<Ref<Int>>

Range typeclass

Advanced for-loops

Proper mutability handling:
 - in compound expressions, e.g. mut.immut.mut.immut ...
 - mutating and non-mutating methods
 - review inheritance and mutability (including interface adapters)

Implement implicit instance initializer function for types' instance members' inlined initializers

Implement implicit static initializer function for types' static members and static code?

Type conversions (with if statements)

Dataspace syntax support, continued

break and continue out of nested loops

Tuple literals
Array literals

Destructors

Union typeclass

Full dataspaces support

Shared objects

Overhaul function overloading (permitting "near-matches") together with implicit type conversion code

Implement symbol visibility (private etc)

Implicit constructors: if no constructor specified, automatically generate constructors:
 - default (zero arguments) constructor if base type and all members without inlined initializers allow default construction
 - "full" constructor if base type allows default construction and one argument for each member (?)
 
Constructor initialization validation check: That each constructor properly initializes all members (without inlined initializers)

Enum typeclass

Support non-constant static initializers (i.e. executed before main())
