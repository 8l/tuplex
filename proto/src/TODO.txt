
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors) - DONE

Author test harness / automatic testing suite

Refactor TxType instantiation - multi-pass so that "cyclic" references possible

Implement implicit static initializer function for types' static members and static code
Implement implicit instance initializer function for types' instance members' inlined initializers

Fix instantiation of ref-constrained type parameters - they should get unique names,
  which means that ref targets must be partly resolved (producing e.g. my.AType$tx#Ref$Int above)

Fix / revise TYPE parameter declaration. See inheritance doc in TxTypeSpecialization. From genericstest2.tx:
    ----P--I--- my.RInt.tx#Ref#T                                 TYPE      = tx.Int
    ----------- my.ATypeRInt                                     TYPE      = my.AType$tx#Ref  ## is =, should not contain members right?
    ----P--I--- my.ATypeRInt.my#AType#S                          TYPE      = my.RInt          ## should be "moved" to my.AType$tx#Ref ?
    
    ----P--I--- my.AType$tx#Ref                                  TYPE      : tx.Tuple
    ----P--I--- my.AType$tx#Ref.S                                TYPE      = my.ATypeRInt.my#AType#S  ## this seems circular...
    ----P--I--- my.AType$tx#Ref.$GenericBase                     TYPE      = my.AType<TYPE S>

Make fields be "bindings to entities" rather than "entities", in order to fix multi-instantiation in e.g:
  stackObj := AType();  ## allocates twice & copies! 

String datatype

Type reflection, at least for autotesting, some ideas:
    assert static_type(var) == static_type(Ref<Parent>)
    assert type(var^) == type(Child)
    #exptype( var, Ref<Parent> )  ## compilation test, no code generated
    #exptype( var, "$local.Foo.$type" )  ## compilation test, no code generated

Type conversions (with if statements)

Dataspace syntax support, continued

Range typeclass

for-loops

break and continue out of nested loops

Tuple literals
Array literals

Destructors

Union typeclass

Full dataspaces support

Shared objects

Generic type instance fields support (with Any contraint type)
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Make TxType be fully defined upon construction (during type resolution pass)
 - Means base types are fully resolved by subtype construction
 - Static (vtable) and instance field layouts can be done upon construction
 - Target (LLVM) type construction could also be done right away

Enum typeclass
