
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors) - DONE

Author test harness / automatic testing suite - DONE

Change statement syntax from \n to ; - DONE

Change function header syntax from 'func' to ()-> - DONE

Implement syntactic sugar for automatic reference dereferencing (implicit '^') - DONE

Refactor TxType instantiation - multi-pass so that "cyclic" references possible - DONE

Fix instantiation of ref-constrained type parameters (they should get unique names like other specializations) - DONE

Fix / revise TYPE parameter declaration ("hashed" binding members) - DONE

Refactor expression conversion wrapping so that each specialization-index has an independent conversion evaluation - DONE

Generic type instance fields support (with Any contraint type) - DONE
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Proper recursive expression checking (fields; types) - DONE

Remove validation pass (move checks to resolution pass) - DONE

Support recursive type definition by reference (CRTP) (e.g. type Bar Foo< Ref<Bar> >) - DONE!!!!!

Make fields be "bindings to entities" rather than "entities" - DONE
 - in order to fix multi-instantiation in e.g:
  stackObj := AType();  ## shall not allocates twice & copy

Implement "development mode" in compiler, if disabled then:
 - bc file generated by default - DONE
 - no jit by default - DONE
 - no compiler assertions - DONE
 - no trace logging invocations - DONE

Review conversion node handling - DONE
 - should be allocated in node constructors (not decl/resolve passes)

Overhaul concrete fields checking - DONE
 - distinguish between parameters that are ref-constrained and that aren't
 - handle lexically nested generic and non-generic types appropriately

Proper mutability handling: - DONE
 - in compound expressions, e.g. mut.immut.mut.immut ...
 - mutating and non-mutating methods

Array literals - DONE

Make VALUE type parameters proper instance fields and ensure they're correctly initialized - IN PROGRESS
 - implement correct Array type handling

Support augmenting built-in types' definitions in tuplex code - IN PROGRESS

Bounds checking on array element access (add implicit AST for this in TxElemDerefNode) - DONE

Bounds checking on array element assignment - DONE

Simple for-loops

Review and test array object assignment semantics
 - correct setting of L
 - truncation (all elements don't fit in target) ok?

Default initialization of array elements (at least if it's array of arrays)

Range typeclass

Sequence interfaces

String datatype

Dynamic-length arrays tests - bounds checking, copying, etc

Ensure fields are always initialized (with the default constructor if no init expr provided)
 - Remove 'initialization' code from alloca (at least for arrays this will cause double init of C and L)

Advanced for-loops

Support negative array indexing from array end

Implement advanced implicit constructor concept
 - Automatically generate the basic constructor (one argument for each instance member (except const with initializer))
   - basic constructor has 'self' as pseuodo-return value, so user constructors can operate object only after it is properly initialized
 - Allow instance members' inlined initializers?
 - Default (zero arguments) constructor if base type and all members without inlined initializers allow default construction?

Constructor initialization validation check: That each constructor properly initializes all members (without inlined initializers)


Remove assumption that bound parameters are "concrete": Shall be ok to bind interfaces and abstract superclasses.
 - See elementary types that implement Enumerable<E>


Implement implicit static initializer function for types' static members and static code

Type conversions (with if statements)

Dataspace syntax support, continued

break and continue out of nested loops

Generate statically constant operations for statically constant value expressions
 - should also enable arbitrary declaration order of global constants 

Syntactic sugar for ref and array types in type arguments (possibly chained), e.g. Subtype<&Int> instead of Subtype<Ref<Int>>

Implement debugging info

Be able to specialize an immutable version of mutable generic types, so that they can accept immutable type bindings
 - review inheritance and mutability (including interface adapters)

Type reflection, at least for autotesting, some ideas:
    assert static_type(var) == static_type(Ref<Parent>)
    assert type(var^) == type(Child)
    #exptype( var, Ref<Parent> )  ## compilation test, no code generated
    #exptype( var, "$local.Foo.$type" )  ## compilation test, no code generated

Support overloading of virtual methods

Autotests for conversions and default constructions for elementary types
  - both expression construction, stack field construction, and static construction

Tuple literals

Destructors

Union typeclass

Full dataspaces support

Shared objects

Overhaul function overloading (permitting "near-matches") together with implicit type conversion code

Implement symbol visibility (private etc)

Enum typeclass

Support non-constant static initializers (i.e. executed before main())

Ideal concrete fields checking
 - ideally bottom-up: any construct that is dependent on generic parameter causes container to be dependent (and non-concrete)
 - methods may have function signature independent of generics, but contain code that is dependent on generic parameters
