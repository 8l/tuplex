module tx


print( str : &Stringer ) {
    ~buf := GrowableUByteArray();
    str.string( &buf );
    buf.add( 0 );  ## handle empty string and ensure there is a null terminator
    tx.c.puts( buf.array() );
}

print_address( r : Ref ) {
    print( %016x tx._address( r ) );
}


read() -> String {
    ## char * fgets ( char * str, int num, FILE * stream );
    return "dummy";
}


interface ByteWriter {
    abstract write( buf : &[]UByte ) ~ -> Long;
}


interface ByteReader {
    abstract read( buf : &~[]UByte ) ~ -> Long;
}


/** A growable UByte array. */
type ~ GrowableUByteArray implements ByteWriter {
    ## FUTURE: Implement same interfaces as Array
    ## FUTURE: Generalize on element type when we can author Writer<E> (requires the modifiability refactoring)

    _arr : ~&~[]UByte;

    self() {
        self._arr = new ~[8]UByte();
    }

    self( arr : &[]UByte ) {
        self._arr = new ~[arr.L+8]UByte();
        for i in 0..arr.L:
            self._arr[i] = arr[i];
    }

    override write( arr : &[]UByte ) ~ -> Long {
        if self._arr.C-self._arr.L < arr.L {
            tmp := new ~[self._arr.L + arr.L + 8]UByte();
            for i in 0..self._arr.L:
                tmp[i] = self._arr[i];
            ##TODO: delete self._arr;
            self._arr = tmp;
        }
        for i in 0..arr.L:
            self._arr.add( arr[i] );
        return arr.L;
    }

    add( val : UByte ) ~ -> Bool {
        self.write( [ val ] );
        return TRUE;
    }

    array() -> &[]UByte {
        return self._arr;
    }
}
