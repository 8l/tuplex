## Tests modifiability in combination with generic type parameters for user types

## TODO: add immutable variant

type ~ GType<S,T,U> {
    sfield : S;
    tfield : T;
    ufield : U;
    ## TODO: add arrays of S and T

    self( s : S, t : T, u : U ) {
        self.sfield = s;
        self.tfield = t;
        self.ufield = u;
    }

    get_s()->S {
        #experr: self.sfield = 5;
        return self.sfield;
    }

    get_t()->T {
        #experr: self.tfield = 6.3;
        return self.tfield;
    }

    get_u()->U {
        #experr: self.ufield = TRUE;
        return self.ufield;
    }

    set_s( s : S ) mod {
        self.sfield = s;
    }

    set_t( t : T ) mod {
        self.tfield = t;
    }
}

main()->Int {
## TODO: be able to specialize an immutable version of mutable generic types, so that they can accept immutable type bindings
    type ImmSpec : GType<Int,Float,Bool>;
    type MutSpec : ~GType<~Int,~Float,Bool>;
    #experr 2: type BadSpec : ~GType<Int,Float,Bool>;

    {
        nonmodI := <GType<Int,Float,Bool>>( 2, 3.14, TRUE );
        smodI   := <GType<~Int,Float,Bool>>( 2, 3.14, TRUE );
        tmodI   := <GType<Int,~Float,Bool>>( 2, 3.14, TRUE );
        allmodI := <GType<~Int,~Float,Bool>>( 2, 3.14, TRUE );
    }

    {
        #experr 0: nonmodM := <~GType<Int,Float,Bool>>( 2, 3.14, TRUE );  ## 0 errs since BadSpec above already created type spec
        #experr 1: smodM   := <~GType<~Int,Float,Bool>>( 2, 3.14, TRUE );
        #experr 1: tmodM   := <~GType<Int,~Float,Bool>>( 2, 3.14, TRUE );
                   allmodM := <~GType<~Int,~Float,Bool>>( 2, 3.14, TRUE );
    }

    return 0;
}
