module my

## tests specializations of ref-bound generic type

type AType<S derives Ref> mod derives Tuple {
    public memref : S;
    public type GenAlias S;
    public type GenRef Ref<S>;

    public self(s : S) {
        self.memref = s;
    }

    public getref()->S {
        return self^.memref;
    }
}

type RInt Ref<Int>;

type ATypeRInt AType<RInt>;

#experr: type BadAType derives AType<Float> { ## doesn't match parameter's constraint type
}

main()->Int {
    #experr: type Err AType<Byte>;  ## doesn't match parameter's constraint type
    #experr: err : AType<Short>;     ## doesn't match parameter's constraint type

    ## fix experr for this case:
    ## #experr: type Err AType<AType>; ## doesn't match parameter's constraint type

    val : Int = 42;
    aobj : ATypeRInt;
    sobj := ATypeRInt(val);
    hobj := new ATypeRInt(val);
    s1 : sobj.S;
    ##s2 : sobj.my#AType#S;  ## FIXME: fix bug where sobj type is my.AType<tx#Ref> rather than my.ATypeRInt (because inherited constructor?)
    ##s2 : hobj^.S;  ## type expr doesn't handle ^

    assert sobj.getref()^ == 42;
    assert hobj.getref()^ == 42;
    return 0;
}
