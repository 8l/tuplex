## Test valid and invalid recursive type definitions

type Node derives Tuple {
    parent : Ref<Node>;

    self() {  ## creates root
        self.parent = self;  ## UNSAFE if obj copied
    }
    self(parent : Ref<Node>) {
        self.parent = parent;
    }

    get_parent()->Ref<Node> {
        return self.parent;
    }

    is_root()->Bool {
        return self == self.parent;
    }

    get_depth()->Int {
        if self.is_root()
            return 1;
        return self.get_parent().get_depth() + 1;
    }
}


## guard against recursive type definitions:

#experr: type First Secnd;
#experr: type Secnd First;


## data recursion via reference is OK:

type A {
    bref : &B;
}
type B {
    aref : &A;
    aobj : A;
}


## data type can't contain itself, directly or indirectly:

type AA {
    bbobj : BB;
}
type BB {
    aaref : &AA;
    aaobj : AA;
}

type CC {
    ccobj : CC;
}


## generic type can't specify itself as a base type's type parameter (except via reference):

type GenType<T> {
    member : T;
}

#experr: type SpecTypeErr   GenType<SpecTypeErr>;

#experr: type SpecTypeErrA  GenType<SpecTypeErrB>;
#experr: type SpecTypeErrB  GenType<SpecTypeErrA>;

/* TODO: Support recursive type definition by reference (needed to support CRTP)
// (See TypeRegistry::get_type_specialization())
type SpecTypeOk    GenType<Ref<SpecTypeOk>>;

type ARef Ref<BRef>;
type BRef Ref<ARef>;

type CRef &DRef;
type DRef &CRef;
*/

main()->Int {
    root   := new Node();
    child1 := new Node(root);
    child2 := new Node(child1);
    depth := child2.get_depth();
    assert depth == 3;
    return 0;
}
