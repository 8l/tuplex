
## 'abstract' tests

#experr: forward_func()->Int;  ## "forward declaration" free functions not currently supported

#experr: abstract_func()->Int;  ## "abstract" free functions not currently supported

#experr 2: abstract concrete_func()->Int { return 2; }


## an abstract (non-interface) type can have both abstract and concrete members:
abstract type AbstractType derives Tuple {
    public static foo : Int = 2;
    public static abstract bar : Int;
    #experr 1: public static abstract bad : Int = 3;  ## can't specify initializer for abstract field
    #experr 3: static abstract mac : Int;             ## 'abstract' fields cannot be private (since private are non-virtual)
    
    public instanceField : Int;
    #experr: public abstract abstrInstanceField : Int;  ## instance fields can't be abstract

    abstract abstr_method()->Int;

    #experr: abstract concrete_method()->Int { return 2; }  ## can't specify initializer for abstract field

    concrete_method2()->Int { return 2; }
}

## a concrete type can't have abstract members:
type ConcreteType derives Tuple {
    public static foo : Int = 2;
    #experr 1: public static abstract bar : Int;      ## a concrete type can't have abstract members
    #experr 2: public static abstract bad : Int = 3;  ## can't specify initializer for abstract field
    #experr 3: static abstract mac : Int;             ## 'abstract' fields cannot be private (since private are non-virtual)

    public instanceField : Int;
    #experr: public abstract abstrInstanceField : Int;  ## instance fields can't be abstract

    #experr 1: abstract abstr_method()->Int;          ## a concrete type can't have abstract members:

    #experr: abstract concrete_method()->Int { return 2; }  ## can't specify initializer for abstract field

    concrete_method2()->Int { return 2; }
}



## interface tests

interface IntfA {
    public abstract get_value()->Int;

    ## "mixin" or default-implementation interface methods:
    public mixin_method_1()->Int { return 1; }
    public mixin_method_2()->Int { return 2; }

    #experr 1: instField : Int;  ## interface can't have instance members
    public static ifField : Int = 17;
}

type Type derives Tuple, IntfA {
    fld : Int;

    self(f : Int) { self.fld = f; }

    public override get_value()->Int {
        assert self.mixin_method_1() == 1;
        ##assert super.mixin_method_2() == 2;  ## TODO: support referring to interfaces via 'super'
        return self.fld;
    }

    public override mixin_method_2()->Int {
        return 3;
    }

    #experr 1: public abstract abstr_method()->Int;  ## Type isn't declared abstract
}

## can't inherit object type in 2nd position
#experr: interface EType derives IntfA, Tuple {
}

## must declare abstract if missing concrete members
#experr 1: type IncompleteType derives Tuple, IntfA {
}
abstract type AbstrIncomplType derives Tuple, IntfA {
}

## implementation member type must match interface member's type
abstract type ErrImplType derives Tuple, IntfA {
    public override mixin_method_2()->Int { return 10; }
    #experr 1: public override mixin_method_1()->UByte { return 20; }
    #experr 1: public override get_value()->Float { return 3.14; }
}



## implementing multiple interfaces

interface IntfX {
    public abstract get_value()->Int;

    public mixin_method_1()->Int { return 1; }
}

interface IntfY {
    public abstract get_value()->Int;
}

interface IntfZ {
    public abstract get_value()->Int;

    public mixin_method_1()->Int { return 5; }
}


type TypeOk derives Tuple, IntfX, IntfY {
    public override get_value()->Int { return 14; }
}

## colliding mixin methods - should this be an error?
type TypeErr1 derives Tuple, IntfX, IntfZ {
    public override get_value()->Int { return 14; }
}

## double implementation - should this be an error/warning?
type TypeErr2 derives Tuple, IntfX, IntfX {
    public override get_value()->Int { return 14; }
}



main()->Int {
    t := Type(42);
    r : &IntfA = &t;
    assert t.ifField == 17;
    assert r.ifField == 17;
    assert r.get_value() == 42;
    assert r.mixin_method_1() == 1;
    assert t.mixin_method_1() == 1;
    assert r.mixin_method_2() == 3;
    assert t.mixin_method_2() == 3;
    return 0;
}
