
## 'abstract' tests

#experr: forward_func()->Int;  ## "forward declaration" free functions not currently supported

#experr: abstract_func()->Int;  ## "abstract" free functions not currently supported

#experr 2: abstract concrete_func()->Int { return 2; }


## an abstract (non-interface) type can have both abstract and concrete members:
abstract type AbstractType derives Tuple {
    public static foo : Int = 2;
    public static abstract bar : Int;
    #experr 1: public static abstract bad : Int = 3;  ## can't specify initializer for abstract field
    #experr 2: static abstract mac : Int;             ## 'abstract' fields cannot be private (since private are non-virtual)
    
    public instanceField : Int;
    #experr: public abstract abstrInstanceField : Int;  ## instance fields can't be abstract

    abstract abstr_method()->Int;

    #experr: abstract concrete_method()->Int { return 2; }  ## can't specify initializer for abstract field

    concrete_method2()->Int { return 2; }
}

## a concrete type can't have abstract members:
type ConcreteType derives Tuple {
    public static foo : Int = 2;
    #experr 0: public static abstract bar : Int;      ## a concrete type can't have abstract members
    #experr 1: public static abstract bad : Int = 3;  ## can't specify initializer for abstract field
    #experr 2: static abstract mac : Int;             ## 'abstract' fields cannot be private (since private are non-virtual)

    public instanceField : Int;
    #experr: public abstract abstrInstanceField : Int;  ## instance fields can't be abstract

    #experr 0: abstract abstr_method()->Int;          ## a concrete type can't have abstract members:

    #experr: abstract concrete_method()->Int { return 2; }  ## can't specify initializer for abstract field

    concrete_method2()->Int { return 2; }
}



## interface tests

type IntfA derives Interface {
    public abstract get_value()->Int;

    ## "mixin" or default-implementation interface methods:
    public mixin_method_1()->Int { return 1; }
    public mixin_method_2()->Int { return 2; }

    #experr 0: instField : Int;  ## interface can't have instance members
    public static ifField : Int = 17;
}

/* future syntax?
interface IntfA {
    public abstract get_value()->Int;
}
*/

type Type derives Tuple, IntfA {
    fld : Int;

    self(f : Int) { self.fld = f; }

    public override get_value()->Int {
        assert self.mixin_method_1() == 1;
        ##assert super.mixin_method_2() == 2;  ## TODO: support referring to interfaces via 'super'
        return self.fld;
    }

    public override mixin_method_2()->Int {
        return 3;
    }

    #experr 0: public abstract abstr_method()->Int;  ## Type isn't declared abstract
}

## can't inherit object type in 2nd position
#experr: type EType derives IntfA, Tuple {
}

## must declare abstract if missing concrete members
#experr 0: type IncompleteType derives Tuple, IntfA {
}
abstract type AbstrIncomplType derives Tuple, IntfA {
}


main()->Int {
    t := Type(42);
    r : &IntfA = &t;
    assert t.ifField == 17;
    assert r.ifField == 17;
    assert r.get_value() == 42;
    assert r.mixin_method_1() == 1;
    assert t.mixin_method_1() == 1;
    assert r.mixin_method_2() == 3;
    assert t.mixin_method_2() == 3;
    return 0;
}
