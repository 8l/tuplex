
public interface Comparable< E > derives Interface {
    public abstract compare( other : E ) -> Int;
}

public interface Enumerable< E derives Enumerable<E> > derives Comparable< E > {

    public static abstract value( ordinal: ULong ) -> E;

    public abstract ordinal() -> ULong;

/* TODO: support AST copies of expressions containing scalar conversion nodes
    public override compare( other : E ) -> Int {
        if self.ordinal() < other.ordinal()
            return -1;
        else if self.ordinal() > other.ordinal()
            return 1;
        else
            return 0;
    }
*/
}

public type MyUInt derives Tuple, Enumerable< MyUInt > {
    public static override value( ordinal: ULong ) -> MyUInt {
        return MyUInt( UInt( ordinal ) );
    }

    val : UInt;

    public self( value : UInt ) {
        self.val = value;
    }

    public override ordinal() -> ULong {
        return self.val;
    }

    public override compare( other : MyUInt ) -> Int {
        if self.ordinal() < other.ordinal():
            return -1;
        else if self.ordinal() > other.ordinal():
            return 1;
        else
            return 0;
    }
}

main() -> Int {
    var1 := MyUInt( 1 );
    var2 := MyUInt( 2 );
    assert var1.ordinal() == 1;
    assert var2.ordinal() == 2;
    assert var1.compare( var2 ) == -1;
    return 0;
}
