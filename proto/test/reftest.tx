/*
func ref_test( r : ref mod Int ) {
    r .= 32;
} 
*/

func puts(str : &[]UByte) {
    tx.c.puts(str^[0])
}

func assert(expected : Bool, actual : Bool) {
    if expected == actual {
        return
    }
    if expected {
        puts(c"Expected TRUE but was FALSE")
    }
    else {
        puts(c"Expected FALSE but was TRUE")
    }
}

func assert(expected : Int, actual : Int) {
    if expected == actual {
        return
    }
    puts(c"Expected M but was N")
}

func print(b : Bool) {
    if b
        puts(c"TRUE")
    else
        puts(c"FALSE")
}

func basic_ref_syntax() Int {
    otherO : ~Int = 2
    __o : ~ Int
    _ro : ~ & ~ Int
    rro : ~ & ~ & ~ Int
    
    __o   = otherO
    _ro   = &__o
    rro   = &_ro

    b : ~Bool
    b =   __o   == otherO  ; assert(TRUE, b)
    b =   _ro^  == otherO  ; assert(TRUE, b)
    b =   rro^^ == otherO  ; assert(TRUE, b)
    
    b =   &__o  == &otherO  ; assert(FALSE, b)
    b =    _ro  == &otherO  ; assert(FALSE, b)
    b =    rro^ == &otherO  ; assert(FALSE, b)

    b =   __o   < otherO  ; assert(FALSE, b)
    b =   _ro^  < otherO  ; assert(FALSE, b)
    b =   rro^^ < otherO  ; assert(FALSE, b)
    
    assert(2, __o)
    _ro^  = 3         ; assert(3, __o)
    rro^^ = 4         ; assert(4, __o)
    
    rro^  = &otherO   ; assert(2, otherO)
    _ro^  = 3         ; assert(3, otherO)
    rro^^ = 4         ; assert(4, otherO)

    /*
    __o   += otherO
    _ro^  += otherO
    rro^^ += otherO
    
    __o.normalize()
    _ro.normalize()  // syntactic sugar
    _ro^.normalize()
    rro^.normalize()  // syntactic sugar
    rro^^.normalize()
    */

    return __o + _ro^ + rro^^
}

/*
func heap_test() Int {
    heapVar : &~Int = new ~Int()
    heapRef : &~&~Int = new ~&~Int()
    heapVar^ = 2
    heapRef^ = heapVar
    heapArr := new Array<Int,100>()
    return heapRef^^
}
*/

func main() Int {
    ret1 := basic_ref_syntax()
    ##ret2 := heap_test()
    return ret1
}
