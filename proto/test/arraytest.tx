##func cstr(Int v)

FOO_STR := c"foo"
FOO_CHR1 := c"foo"[1]
FOO_CHR2 := FOO_STR[1]

func ret_array() &[]UByte {
    s : [4]UByte = FOO_STR
    t : &[]UByte = FOO_STR
    ## u : [4]UByte = t  ## ERROR
    puts(s)
    return t
    ##return c"foo"
}

func puts(cstr : &[]UByte) {
    tx.c.puts(cstr^[0])
}

func basic_array_syntax() Int {
    puts( ret_array() )

    a : ~Array<~UByte,10>
    b : ~[10]~UByte;
    c := c"1234567890"
    b[0] = c"123"[2]
    b[1] = c[1]
    b[2] = c[0]
    b[3] = UByte(0)
    puts(b)  ## expect "321"
    a = b
    puts(a)  ## expect "321"
    return c[2]-48  ## 48 is ASCII '0'
}


func setelem(cstr : &~[]UByte, i : Int, chr : UByte) {
    cstr^[i] = chr
}

func array_modifiability() {
    cs : [4]UByte = c"cst"
    crcs : &[]UByte = cs    ## implicit reference
    mrcs : ~&[]UByte = cs   ## implicit reference
    /* the following are illegal:
    cs = c"qqq"
    cs[0] = 'A'
    crcs^[0] = 'A'
    mrcs^[1] = 'B'
    setelem(crcs, 2, 'C')
    setelem(mrcs, 2, 'C')
    */
    puts(mrcs)  ## expect "cst"

    ms : ~[4]~UByte = c"mod"
    crms : &~[]UByte = &ms   ## explicit reference required
    mrms : ~&~[]UByte = &ms  ## explicit reference required
    mrms = crms
    ms[0] = 'A'
    crms^[0] = 'A'
    mrms^[1] = 'B'
    setelem(&ms, 2, 'C')  ## explicit reference required
    setelem(crms, 2, 'C')
    setelem(mrms, 2, 'C')
    /* the following are illegal:
    crms = mrms
    mrms = &cs
    mrms = crcs
    mrms = mrcs
    */
    puts(mrms)  ## expect "ABC"

    ms = c"qqq"
    puts(mrms)  ## expect "qqq"

    ##crms^ = mrcs^  ## FIXME: dynamic concrete type resolution
    crms_ : &~[4]UByte = &ms
    mrcs_ : ~&[4]UByte = cs
    crms_^ = mrcs_^
    puts(ms)  ## expect "cst"

    conststr := c"1234567890"
    strcopy : ~[11]~UByte;
    strcopy = conststr
}

func main() Int {
    array_modifiability()
    return basic_array_syntax()
}
