module my

type AType mod derives Tuple {
    field1 : Long
    field2 : Float
    field3 : ~Bool

    public self() {
        self(17, 3.14)
        self^.field3 = FALSE
    }
    public self(f1 : Long, f2 : Float) {
        if (f1 < 0) {
            self^.field1 = f1
        } else
            self^.field1 = -f1
        self^.field2 = f2
        self^.field3 = TRUE
    }

    public method(a : Int) Int {
        return a * 2
    }
}

type BType mod derives AType {
    field4 : Double

    public self(f4 : Double) {
        super()
        self^.field4 = f4
    }
    public self(f1 : Long, f2 : Float) {
        super(f1, f2)
        self^.field4 = f2
    }

    public method(a : Int) Int {
        return super^.method( a ) * 2
    }
}

object_construction() Int {
    stackObj := AType()
    ##stackRef := ~&~AType(&stackObj)
    heapObj1 := new AType()
    heapObj2 := new AType(2, 2.71)
    heapObj3 := new BType(1.1)
    heapObj4 := new BType(101, 2.71)
    ##return Int( heapObj4^.field1 )
    return heapObj4^.method( 2 )
}

builtin_construction() Int {
    stackBool := Bool(FALSE)
    heapBool := new Bool(TRUE)

    stackInt := Int(-1)
    heapInt := new Int(2)

    stackDouble := Double(-123.456)
    heapDouble := new Double(3.141592)

    heapVar : &~Int = new ~Int(0)
    heapVar^ = 2

    /*
    heapRef := <Ref<Scalar>>(heapVar)
    heapRef := <&Scalar>(heapVar)
    heapRef := new Ref<Scalar>(heapVar)

    heapRef : &~&~Int = new ~&~Int(heapVar)
    heapRef^ = heapVar
    heapArr := new Array<Int,100>()
    return heapRef^^
    */
    return heapVar^
}

mod_test() Int {
    ~iv := Int(3)
    iv = 4
    ~ir := new ~Int(3)
    ir^ = 4
    ir = new ~Int(5)
    iv2 := (new Int(3))^ + Int(3)
    return iv2
}

main() Int {
    ret0 := mod_test()
    ret1 := object_construction()
    ret2 := builtin_construction()
    return ret1
}
