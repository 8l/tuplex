module my

##import tx.proto.print.*

public type MARef<T> &T

public type MBRef<T> Ref<T>

public type MCRef<T> derives Ref<T> {
    static SFIELD := 3
}

public type MDRef<T derives Any> Ref<T>

public type MERef<T derives Any> derives Ref<T> {
    static SFIELD := 3
}

public type MFRef<Q> Ref<Q>
public type MGRef<T> MFRef<T>


public type NAArray<E> [10]E

public type NBArray<E> Array<E,10>

public type NCArray<E> derives Array<E,10> {
}



type Type<E,L:UInt> derives Tuple {
}

## not yet supported to rename value parameter:
type Midtype<F,L:UInt> Type<F,(L)>
##type Midtype<F,L:UInt> Type<F>

LEN : UInt = 5
type GlobalType Midtype<Float,(LEN)>

func generics_test() Int {
    len := 10UI
    type LocalTypeX Midtype<Float,(len)>
    type LocalTypeY Midtype<Int,(UInt(12+1))>
    x : LocalTypeX
    y : LocalTypeY
    xe1 : x.E
    xe2 : x.my#Type#E
    xf1 : x.F
    xf2 : x.my#Midtype#F
    ye1 : y.E
    ye2 : y.my#Type#E
    yf1 : y.F
    yf2 : y.my#Midtype#F
    xl1 := x.L
    xl2 := x.my#Midtype#L
    ## xl3 := x.my#Type#L  NOT SUPPORTED YET
    yl1 := y.L
    yl2 := y.my#Midtype#L
    ## yl3 := y.my#Type#L  NOT SUPPORTED YET
    return Int(xl1-xl2 + yl1-yl2)
}

/*
func dynamic_generics_test(len : UInt) Int {
    type DynamicType Midtype<Float,(len)>
    a : DynamicType
    return Int(a.K)
}
*/

    
func main() Int {
    var : Float = 13.2
    varr := &var
    varr2 : MGRef<Float> = varr

    result := generics_test()
    return result
}


/*

Array<E,L> {
    generic type E
    generic L Int
}

Subtype<F,K> derives Array<Ref<F>,(K+1)> {
    generic type F
    generic K Int

    ## reinterpretation in usage scope via alias:
    type tx#Array#E is Ref<Subtype.F>

    ## reinterpretation in usage scope via reentrant expr?
    ## that still only supports static values though
    tx#Array#L is Subtype.K+1
}

ConcreteType derives Subtype<Int, 2> {
    type Subtype#F Int
    Subtype#K := 2
}

*/