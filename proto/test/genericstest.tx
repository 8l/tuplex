module my

##import tx.proto.print.*

public type MARef<T> &T

public type MBRef<T> Ref<T>

public type MCRef<T> derives Ref<T> {
    static SFIELD := 3
}

public type MDRef<T derives Any> Ref<T>

public type MERef<T derives Any> derives Ref<T> {
    static SFIELD := 3
}

public type MFRef<Q> Ref<Q>
public type MGRef<T> MFRef<T>


public type NAArray<E> [10]E

public type NBArray<E> Array<E,10>

public type NCArray<E> derives Array<E,10> {
}



type Type<E,F> derives Tuple {
    var : &E
}

type SType<E,G> Type<E,G>

func generics_test() Int {
    type LocalTypeX SType<~Float,~Double>
    type LocalTypeY SType<~Int,~Long>
    type LocalTypeZ SType<~Int,~Long>
    x : LocalTypeX
    y : LocalTypeY

    xe1 : x.E           = 1.
    xe2 : x.my#SType#E  = 2.
    xe3 : x.my#Type#E   = 4.
    xg1 : x.G           = 8.
    xg2 : x.my#SType#G  = 16.
    xg3 : x.my#Type#F   = 32.

    ye1 : y.E           = 1
    ye2 : y.my#SType#E  = 2
    ye3 : y.my#Type#E   = 4
    yg1 : y.G           = 8
    yg2 : y.my#SType#G  = 16
    yg3 : y.my#Type#F   = 32

    return Int(xe1 + xe2)
}

/*
func dynamic_generics_test(len : UInt) Int {
    type DynamicType SType<Float,(len)>
    a : DynamicType
    return Int(a.K)
}
*/

    
func main() Int {
    var : Float = 13.2
    varr := &var
    varr2 : MGRef<Float> = varr

    result := generics_test()
    return result
}


/*

Array<E,L> {
    generic type E
    generic L Int
}

Subtype<F,K> derives Array<Ref<F>,(K+1)> {
    generic type F
    generic K Int

    ## reinterpretation in usage scope via alias:
    type tx#Array#E is Ref<Subtype.F>

    ## reinterpretation in usage scope via reentrant expr?
    ## that still only supports static values though
    tx#Array#L is Subtype.K+1
}

ConcreteType derives Subtype<Int, 2> {
    type Subtype#F Int
    Subtype#K := 2
}

*/